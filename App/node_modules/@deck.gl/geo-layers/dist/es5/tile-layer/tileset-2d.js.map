{"version":3,"sources":["../../../src/tile-layer/tileset-2d.js"],"names":["TILE_STATE_UNKNOWN","TILE_STATE_VISIBLE","TILE_STATE_PLACEHOLDER","TILE_STATE_HIDDEN","TILE_STATE_SELECTED","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","Tileset2D","opts","onTileLoad","tile","maxCacheByteSize","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","RequestScheduler","maxRequests","throttleRequests","_cache","Map","_tiles","_dirty","_viewport","_selectedTiles","_frameNumber","setOptions","Object","assign","Number","isFinite","maxZoom","_maxZoom","Math","floor","minZoom","_minZoom","ceil","values","isLoading","abort","clear","keys","tileId","get","includes","delete","setNeedsReload","viewport","zRange","modelMatrix","modelMatrixAsMatrix4","Matrix4","isModelMatrixNew","equals","_modelMatrix","_modelMatrixInverse","clone","invert","tileIndices","getTileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","changed","updateTileStates","tileSize","extent","zoomOffset","x","y","z","bbox","tileIndex","_updateTileStates","selectedTiles","abortCandidates","ongoingRequestCount","isVisible","Boolean","state","isSelected","push","length","shift","parent","children","_getNearestAncestor","refinementStrategy","getPlaceholderInAncestors","needsPlaceholder","getPlaceholderInChildren","maxCacheSize","Infinity","overflown","size","onTileUnload","Array","from","sort","t1","t2","create","needsReload","Tile2DHeader","getTileMetadata","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","onTileError","getParentIndex","every","isLoaded","t","max","child"],"mappings":"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","sourcesContent":["import Tile2DHeader from './tile-2d-header';\nimport {getTileIndices, tileToBoundingBox} from './utils';\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4} from 'math.gl';\n\nconst TILE_STATE_UNKNOWN = 0;\nconst TILE_STATE_VISIBLE = 1;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\nconst TILE_STATE_PLACEHOLDER = 3;\nconst TILE_STATE_HIDDEN = 4;\n// tiles that should be displayed in the current viewport\nconst TILE_STATE_SELECTED = 5;\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nconst DEFAULT_CACHE_SCALE = 5;\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class Tileset2D {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts) {\n    this.opts = opts;\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: opts.maxRequests > 0\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n\n  get isLoaded() {\n    return this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll() {\n    for (const tileId of this._cache.keys()) {\n      const tile = this._cache.get(tileId);\n      if (!this._selectedTiles.includes(tile)) {\n        this._cache.delete(tileId);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   * @param {*} modelMatrix\n   */\n  update(viewport, {zRange, modelMatrix} = {}) {\n    const modelMatrixAsMatrix4 = new Matrix4(modelMatrix);\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!viewport.equals(this._viewport) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrix && modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrix && modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  /* Public interface for subclassing */\n\n  // Returns array of {x, y, z}\n  getTileIndices({viewport, maxZoom, minZoom, zRange, modelMatrix, modelMatrixInverse}) {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  // Add custom metadata to tiles\n  getTileMetadata({x, y, z}) {\n    const {tileSize} = this.opts;\n    return {bbox: tileToBoundingBox(this._viewport, x, y, z, tileSize)};\n  }\n\n  // Returns {x, y, z} of the parent tile\n  getParentIndex(tileIndex) {\n    // Perf: mutate the input object to avoid GC\n    tileIndex.x = Math.floor(tileIndex.x / 2);\n    tileIndex.y = Math.floor(tileIndex.y / 2);\n    tileIndex.z -= 1;\n    return tileIndex;\n  }\n\n  // Returns true if any tile's visibility changed\n  updateTileStates() {\n    this._updateTileStates(this.selectedTiles);\n\n    const {maxRequests} = this.opts;\n\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    let changed = false;\n    for (const tile of this._cache.values()) {\n      const isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n      if (tile.isVisible !== isVisible) {\n        changed = true;\n        tile.isVisible = isVisible;\n      }\n\n      // isSelected used in request scheduler\n      tile.isSelected = tile.state === TILE_STATE_SELECTED;\n\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    if (maxRequests > 0) {\n      while (ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n        // There are too many ongoing requests, so abort some that are unselected\n        const tile = abortCandidates.shift();\n        tile.abort();\n        ongoingRequestCount--;\n      }\n    }\n\n    return changed;\n  }\n\n  /* Private methods */\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      tile.children.length = 0;\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile.x, tile.y, tile.z);\n      tile.parent = parent;\n      if (parent) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  // A selected tile is always visible.\n  // Never show two overlapping tiles.\n  // If a selected tile is loading, try showing a cached ancester with the closest z\n  // If a selected tile is loading, and no ancester is shown - try showing cached\n  // descendants with the closest z\n  _updateTileStates(selectedTiles) {\n    const {_cache} = this;\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.state = TILE_STATE_UNKNOWN;\n    }\n\n    // For all the selected && pending tiles:\n    // - pick the closest ancestor as placeholder\n    // - if no ancestor is visible, pick the closest children as placeholder\n    for (const tile of selectedTiles) {\n      tile.state = TILE_STATE_SELECTED;\n    }\n\n    if (refinementStrategy === STRATEGY_NEVER) {\n      return;\n    }\n    for (const tile of selectedTiles) {\n      getPlaceholderInAncestors(tile, refinementStrategy);\n    }\n    for (const tile of selectedTiles) {\n      if (needsPlaceholder(tile)) {\n        getPlaceholderInChildren(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [tileId, tile] of _cache) {\n        if (!tile.isVisible) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(tileId);\n          this.opts.onTileUnload(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values())\n        // sort by zoom level so that smaller tiles are displayed on top\n        .sort((t1, t2) => t1.z - t2.z);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  _getTile({x, y, z}, create) {\n    const tileId = `${x},${y},${z}`;\n    let tile = this._cache.get(tileId);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader({x, y, z});\n      Object.assign(tile, this.getTileMetadata(tile));\n      needsReload = true;\n      this._cache.set(tileId, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(x, y, z) {\n    const {_minZoom = 0} = this;\n    let index = {x, y, z};\n\n    while (index.z > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n// A selected tile needs placeholder from its children if\n// - it is not loaded\n// - none of its ancestors is visible and loaded\nfunction needsPlaceholder(tile) {\n  let t = tile;\n  while (t) {\n    if (t.state & (TILE_STATE_VISIBLE === 0)) {\n      return true;\n    }\n    if (t.isLoaded) {\n      return false;\n    }\n    t = t.parent;\n  }\n  return true;\n}\n\nfunction getPlaceholderInAncestors(tile, refinementStrategy) {\n  let parent;\n  let state = TILE_STATE_PLACEHOLDER;\n  while ((parent = tile.parent)) {\n    if (tile.isLoaded) {\n      // If a tile is loaded, mark all its ancestors as hidden\n      state = TILE_STATE_HIDDEN;\n      if (refinementStrategy === STRATEGY_DEFAULT) {\n        return;\n      }\n    }\n    parent.state = Math.max(parent.state, state);\n    tile = parent;\n  }\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    child.state = Math.max(child.state, TILE_STATE_PLACEHOLDER);\n    if (!child.isLoaded) {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"],"file":"tileset-2d.js"}